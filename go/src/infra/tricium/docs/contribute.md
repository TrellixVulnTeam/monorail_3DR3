# Tricium Analyzer Contribution

This doc is intended for readers who are interested in building and deploying a
new Tricium Analyzer. A *Tricium Analyzer* can automatically produce
conveniently timed warnings and suggestions for changes under review in your
project, in the form of code review comments.

## Overview of Tricium Functions

First, some background information:

### Data Types

The input and output types that Tricium Analyzers can take are defined in
[data.proto](../api/v1/data.proto); there are three main important types:

*   `GIT_FILE_DETAILS`: Just the information required to fetch the repository,
    but without any file contents. This doesn't include the actual contents of
    the file, but it does include the git repository URL and ref string as well
    as a list of files.
    [Example](../functions/git-file-isolator/test/tricium/data/git_file_details.json).
*   `FILES`: The list of files and file metadata, along with the actual contents
    of the files. The file metadata includes the relative path, how the file was
    changed, and whether it is binary or text. Many simple Analyzers that depend
    on just the text of the files changed in the CL can use this type. This
    input type does not include repository URL or git ref.
    [Example](../functions/spacey/test/tricium/data/files.json).
*   `RESULTS`: The result of an Analyzer, which is a list of comments to post,
    as well as (optionally) the platform that the results apply to. Results are
    generated
    [Example in a unit test](../functions/spellchecker/spellchecker_test.go); an
    example output can be generated by running `make test` in one of the
    analyzer directories like [../functions/spellchecker].

### Function Types

A **Function** takes some input and produces some output; there are two types:
Isolators and Analyzers.

An **Isolator** generates some intermediate output type other than `RESULTS`.
The only **Isolator** as of this writing is called `GitFileIsolator`; it takes
`GIT_FILE_DETAILS` as an input, checks out the file contents, and stores the
file contents on the
[Isolated Server](https://chromium.googlesource.com/infra/luci/luci-py/+/HEAD/appengine/isolate/doc/Design.md)
so that they can be subsequently fetched by other Functions during one run.

An **Analyzer** takes some input and produces Tricium `RESULTS`. Results of
Analyzers can be visible as comments in code review.

Various different Analyzers may potentially use different input data types; if
they require just file contents, then they depend on `FILES`; if they require
just CL metadata, then they can depend on `GIT_FILE_DETAILS`. How best to
implement Analyzers that depend on files outside of the CL is an open question,
see [bug 924769](https://crbug.com/924769).

## Example Functions

Many useful Analyzers implemented in Go are located in
[tricium/functions/](../functions/).

### Linters

Third-party language-specific "linter" programs exist for many languages; to
adapt them for Tricium, we need to make a wrapper that will run the program and
produce Tricium `RESULTS`, such as [Pylint](../functions/pylint/).

If third-party dependencies are required, they should be fetched and included in
the CIPD package, but generally shouldn't be checked into source. The
dependencies may be fetched using a set-up script that is run at package-build
time. For example, the [ESLint](../functions/eslint/) Analyzer uses a script
called setup.py that is run before building and uploading a CIPD package.

### Simple Regex-based Checkers

Some checks may also just read the input files and check for certain text
patterns. Examples include [Copyright](../functions/copyright/).

## Implementing an Analyzer

### Types of Analyzer Implementation

**Simple Analyzers**, such as those in [tricium/functions/](../functions/) are
programs which read input from JSON and write output to JSON. Each program is
packaged and deployed using
[CIPD](https://cs.chromium.org/chromium/infra/go/src/go.chromium.org/luci/cipd/README.md).

To create a simple Analyzer, create a binary that consumes needed Tricium data,
by reading from a `tricium/data/<input-type>.json` file, and produces Tricium
data, by writing to a `tricium/data/<output-type>.json` file. It's recommended,
for consistency with existing Analyzers, to include a Makefile to build and
package the Analyzer.

It's also possible to implement an Analyzer as a
**[Recipe](https://cs.chromium.org/chromium/infra/recipes-py/README.md)-based
Analyzer**. Existing examples of this are in the Fuchsia project.

### Building

To build the Go Analyzers examples, you should first set up the infra Go
environment; see [The infra Go README.](../../../../README.md). After the
environment is set up, running `go build` in the directory should produce a
usable binary.

### Local Testing

Besides writing unit tests, you can also test run your Analyzer locally, because
the Analyzer is just a program that reads from local files and writes to local
files. You can make an example test input directory, for example
[tricium/functions/spacey/test/](../functions/spacey/test/).

Then, you can build your program (if necessary) and run it. For Go programs,
this may be done by running `go build` and then invoking the resulting binary
with the arguments `-input` and `-output`.

### "End-to-End" Testing

Before deploying and enabling widely for a project, you can test an Analyzer by
enabling it in
[the playground repository](https://chromium.googlesource.com/playground/gerrit-tricium/),
by editing
[the config](https://chromium.googlesource.com/playground/gerrit-tricium/+/refs/heads/infra/config/tricium-dev.cfg).
You can then create example changes in that repository to see the Tricium dev
instance run your Analyzer on your example change.

First, however, you must deploy your Analyzer as a CIPD package and decide what
config parameters to use in the config. See the sections below, include the
section about testing and release.

### Packaging with CIPD

Make sure you have the CIPD client installed; see
[installation instructions](https://dev.chromium.org/developers/how-tos/install-depot-tools).
Add a `cipd.yaml` file to the root of your Analyzer's directory tree, e.g.
[hello/cipd.yaml](../functions/hello/cipd.yaml):

```
package: infra/tricium/function/hello
install_mode: symlink
data:
        - file: hello
```

Note that package should be `infra/tricium/functions/ANALYZER`, replacing
CamelCase (e.g. ClangTidy) with words separated with dashes, e.g. (clang-tidy).
The data section should list files to be included in the CIPD package; see
[cipd/client/cipd/local/pkgdef.go](https://github.com/luci/luci-go/blob/master/cipd/client/cipd/local/pkgdef.go#L35)
for details.

### Deploying with CIPD

Run the CIPD command line tool to create and tag the new release. If the CIPD
client complains about a lack of authentication, contact tricium-dev@google.com
to get added to the "tricium-contributors" group.

Uploading a new version of an Analyzer usually has two steps: uploading a new
instance and setting the ref "live" to that instance.

There is a convenience helper script [update.sh](../functions/update.sh) which
may be used to update Analyzers.

```
$ cipd create -pkg-def cipd.yaml
â€¦
infra/tricium/function/hello:5b010cd78bc78252dda3e791cd6510c56111a990 was successfully registered
$ cipd set-ref infra/tricium/functions/hello -ref live -version 5b010cd78bc78252dda3e791cd6510c56111a990
[P26551 20:36:06.432 client.go:1004 I] cipd: setting ref of "infra/tricium/function/hello": "live" => "5b010cd78bc78252dda3e791cd6510c56111a990"
Packages:
  infra/tricium/function/hello:5b010cd78bc78252dda3e791cd6510c56111a990
```

NB! If your Analyzer contains compiled binaries, make sure that the target
platform for your built binaries are the same as the platform that will run the
Analyzer; for example, if it will run on Windows, you must build for Windows.
The place where the runtime platform is configured is in the Analyzer
definition; see the example config below, which specifies "UBUNTU".

### About CIPD Packages

CIPD packages are basically zip files with a manifest file. They have an
instance ID which is a digest of the zip package, which may look like
`ZEBe-8SEx5Z3TQ_bby6Ok82WbLc71YPdLEAnGWjmHKsC`.

CIPD package instances have a package name and version. Versions can be the
instance ID, or a ref, such as "live". It's conventional for Tricium Analyzers
to use the "live" ref, which is set in the Analyzer definition in the config
file, as in the example below.

### Configure your Analyzer

There are two different places where Analyzer definitions can be located:

-   The Tricium service configs (either
    [tricium-prod](https://luci-config.appspot.com/#/services/tricium-prod) or
    [tricium-dev](https://luci-config.appspot.com/#/services/tricium-dev))
-   Your project config (example
    [tricium-dev.cfg](https://chromium.googlesource.com/infra/infra/+/infra/config/tricium-dev.cfg)).

In order to re-use an analyzer across projects, the definition of the analyzer
must be added to the service config. You can make a request to tricium-dev@ to
add your analyzer definition. Alternatively, if you have permission to make
changes to the internal repo, general instructions on how to make LUCI service
config changes is at go/luci/onboarding#making-changes.

```
functions {
  type: ANALYZER
  name: "Hello"
  needs: FILES
  provides: RESULTS
  owner: "emso@chromium.org"
  component: "monorail:Infra>Platform>Tricium>Analyzer"
  impls {
    runtime_platform: UBUNTU
    provides_for_platform: UBUNTU
    cmd {
      exec: "hello"
      args: "--output=${ISOLATED_OUTDIR}"
    }
    deadline: 30
    cipd_packages {
      package_name: "infra/tricium/function/hello"
      path: "."
      version: "live"
    }
  }
}
```

In the project config, you'll want to choose what subset of available functions
should be enabled for the project. Here you can add your Analyzer and any
Isolators that it depends on (usually just `GitFileIsolator`).

```
selections {
  function: "GitFileIsolator"
  platform: UBUNTU
}

selections {
  function: "Hello"
  platform: UBUNTU
}
```

### Staging and Release

Deploying to a limited environment:

*   In the project config for a test project connected to `tricium-dev` (e.g.
    [playground/gerrit-tricium](https://chromium.googlesource.com/playground/gerrit-tricium)),
    add the Analyzer definition and selection to the project config. The
    Analyzer definition and selection can both be put in the project config file
    for the playground repository.
*   Upload an example CL that should have comments.
*   If everything is configured correctly, the Gerrit page should show that
    there was a run, and clicking on the run link should show you that your
    Analyzer ran. For help with debugging, if you have questions, reach out to
    tricium-dev@google.com.

Releasing:

*   If the Analyzer is applicable to multiple projects, the definition can go in
    the `tricium-prod` service config (internal). A `tricium-prod.cfg` config
    file for your project must be created or updated to include a selection for
    your Analyzer. The example for chromium/src is at
    [//infra/config/tricium-prod.cfg](https://cs.chromium.org/chromium/src/infra/config/tricium-prod.cfg).

## Analyzer Guidelines

### What Makes a Good Analyzer?

*   An Analyzer should not be too noisy; for example, you should aim for false
    positive rate of less than 10%. That is, messages should be "useful" at
    least 90% of the time. Categories of comments that have been found to be too
    noisy should be disabled or improved.
*   An Analyzer should be fast enough so that results can generally appear
    before the reviewer reviews the CL; for example, you should aim for results
    in under 10 minutes.
*   An Analyzer should produce clear and actionable comments.

A Tricium analyzer can take more time and include more checks than presubmit. It
should find some results when run on the whole codebase, but not too many so
that it's overwhelming.

### How to Release a New Analyzer Version

If you have an Analyzer that's already running and configured, and you want to
release a new version, the following is a general process for release:

First, test locally; try both unit tests and a test-invocation on sample input.
Note, you can run Go unit tests by running `go test ./...`. Make sure you run
this on a machine that is binary-compatible with the actual Swarming task
environment.

Optionally, you could **try with a local devserver instance of Tricium**
(documentation pending; for now, Googlers can see the current doc at
go/tricium-playbook). The advantage of testing it out with a devserver instance
would be that you can change the configs without making any actual commits, by
changing [tricium/appengine/devcfg](../appengine/devcfg/).

After you're ready, upload it as described above in the "Deploy CIPD Package"
section, by running the `cipd` commands yourself or possibly by running
`update.sh my-analyzer` from [tricium/functions](../functions).

Then, again optionally, upload a new patchset or a new CL to confirm that it
works as expected.
