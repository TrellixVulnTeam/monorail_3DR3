# Chrome UI Catalog Viewer Design

## Overview

The Android Chrome UI is large and complicated, and as a result it has been
difficult for the UX team to fully review changes to the UI. To assist with
this, and with UI development, we recently created a framework for writing tests
which capture standard screenshots ([Screenshooter.java](
https://cs.chromium.org/chromium/src/chrome/android/javatests/src/org/chromium/chrome/browser/test/ScreenShooter.java )),
and are now starting to create tests (UI Capture Tests) which generate such
screenshots. The UI Catalog Viewer is a viewer for these screenshots.

The UI Capture Tests, in addition to generating raw screenshots, generate JSON
files describing those screenshots. These files include details of the test that
generated each screenshot, the device on which it was run, and the versions of
Chrome and Android running on that device. The test writer may add other tags to
the screenshots. The UI Catalog Viewer is able filter the displayed  screenshots
based on these properties and tags.

## Requirements

* The UI Catalog Viewer loads screenshots, and the associated metadata, from any
  test run (local or on the bots) that generates such data.
* Users can filter the screenshots displayed based on the metadata generated by
  the UI Capture tests.
* Users can to view the full details of any individual screenshot.
* It is to create a link to any screenshot or screenshot set displayed by the UI
  Catalog Viewer. This link should remain valid so long as the screenshots
  exist.
   * Note that the UI Catalog Viewer does not keep its own copies of the
     screenshots, so cannot control their lifetime.
* Users should be able add comments to the screenshots.
   * This is currently disabled, since it handles user data and therefore
     requires a privacy review.
   * It also needs some work on how the comments are stored and associated with
     particular screenshots.

## Usage model

There are two main ways of using the UI Catalog viewer:
* Running it from the command line to view screenshots generated either by a
  local test run or by a bot.
* Running it as a web app to view screenshots generated by a test run of the
  bot.

Note that only the local version can read and display the output of a local test
run.

When Android build steps that generate screenshots run on the bots, thier output
includes a link to the viewer with the query parameters to display the generated
screenshots.

## Viewer UI

The viewer has two views:
* A summary view that displays a filtered set of screenshots. The user can
select filters and tags on this view to choose which screenshots are displayed.
* A single screenshot view. This displays a single screenshot at a larger scale,
and lists all the data associated with the screenshot.
   * Once comments are implemented this page will shows any comments on the
     screenshot, and allow the user to add new comments or edit their existing
     comments.

## Input data

The viewer gets its data fron a JSON screenshot description file, containing an
array of screenshot descriptions. This file may either in Google storage, or,
when the viewer is run locally, on the local file system. The location of the
description file is either passed to the viewer as a query  parameter on its
URL, or set by the user on the 'set screenshot source' page.

Each screenshot description contains:
* The relative location of the image file
   * This is only valid if data is being read from a local file system.
* A link (URL) for the image.
   * This is set by the test runner when the images are stored in Google
     Storage, and as such may only be valid if the data is being read from
     Google Storage.
* A set of filter values as key/value pairs.
* A set of zero or more tags. These are simple strings.
* Further metadata key/value pairs. This contains additional data generated by
  the tests which may be of interest, but is not useful for filtering the data,
  such as the exact time at which each screenshot was captured.

## Structure

The Viewer has a web front end written in HTML and Javascript, making heavy use
of Polymer 2, and a back end written in Python using WSGI.

### Front End

The front end is implemented as four Polymer pages (children of an `iron-pages`
template). These are the summary view, the screenshot view, the set screenshot
source page, and an error page.

When the site is first opened the front end will read the URL's
`screenshot_source` query parameter, and will send its value to the back end in
a PUT request (generated, like all requests to the back end, by Polymer's
`iron-ajax` template). This tells the back end the location of the screenshot
description file or files.

If the site is opened with no `screenshot_source` query parameter it opens the
set screenshot source page. This lets the user enter a screenshot source.

The summary view is accessed with a URL with an empty path, or a path of
`/summary_view`. In addition to the `screenshot_source` query parameter the URL
may also have a `selection` query parameter containing a JSON description of the
current filter values and selected tags.

The top of the summary page is implemented as Polymer `app_header` containing a
`cuic_shot_selector`. This implements the menus for selecting which shots are
displayed on the rest of the page. It is data driven, fetching a list of all the
filters and tags used by the screenshots from the back end, and building the
menus from these lists. Any user change to these menus will modify the
`selection` query parameter, which will then cause the app to refetch the
screenshots from the back end.

The body of the summary page is a grid of screenshots (implemented, for
efficiency, using Polymer's `_iron-list` template). The summary page sends the
`selection` query parameter to the back end to retreive the list of screenshots.

Clicking on any screenshot takes the user to the screenshot view page for that
screenshot. The screenshot view shows the screenshot and lists all the metadata
for that screenshot.

In future it will also provide the ability to comment on screenshots. This is
currently disabled.

All polymer custom elements defined in the front end use names prefixed with
"cuic-" (short for **C**hrome **UI** **C**atalog).

### Back End

There are two versions of the back end. The local version is used when the
viewer is run from the command line, and can access both local screenshots, and
screenshots stored in Google Cloud Storage. The cloud version is used when the
viewer is run on the Google App Engine, and can only access screenshots stored
in Google Cloud Storage. The source files are local_server.py, and
cloud_server.py, with common code in ui_catalogue.py.

Both versions of the back end are WSGI applications. They provide the following
WSGI responders:

| Name | URL path regex | HTML method | Use | Notes |
| --- | --- | --- | --- | --- |
| SelectorList | /service/selector_list | GET |  Fetch the filters and tags present in the data | |
| ScreenshotListServer | /service/screenshots_list | GET | Fetch a filtered list of screenshots | The requested filters and tags are given in the `filters` and `userTags` query parameters  |
| ImageServer | /service/([^/]*)/image | GET | Fetch the image associated with a screenshot | |
| DataServer | /service/([^/]*)/data | GET | Fetch all the data (except the image) about a screenshot | |
| CommentListServer | /service/([^/]*)/comments | GET | Fetch all comments for a screenshot | |
| | | POST | Add a comment to a screenshot | |
| CommentServer | '/service/([^/]*)/comment/([^/]*)'|  PUT | Replace a comment | Used to edit comments |
| | | DELETE | Delete a comment | |
| StaticFileHandler | /(.*) | GET | Fetch a static file | Only needed in the local server, GAE provides its own static file handler. Ensures that all files accessed are within the source directories. |

All messages have a `screeenshot_source` query parameter, giving the file name
or the url of the screenshot description file. The current screenshot
descriptions and screenshot source are saved between transactions; each
transaction checks whether the screenshot source has changed, and reads the new
description file if it has.

Note:- The CommentServer and CommentListServer are currently unused, pending
design of a back end storage mechanism and a privacy review.
